<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>子数组相关</title>
    <link href="/2024/06/25/%E5%AD%90%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3/"/>
    <url>/2024/06/25/%E5%AD%90%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><ul><li><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/?envType=study-plan-v2&envId=top-interview-150">209. 长度最小的子数组</a></p></li><li><p><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></p></li></ul><h2 id="对应解答及注意事项"><a href="#对应解答及注意事项" class="headerlink" title="对应解答及注意事项"></a>对应解答及注意事项</h2><h3 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/?envType=study-plan-v2&envId=top-interview-150">长度最小的子数组</a></h3><blockquote><ul><li>这个题是滑动窗口的最佳实践！窗口有左右两个边界索引，有点类似于<em><strong>双指针</strong></em>的方法</li><li>官方题解有一个前缀和的做法：<strong>提前算出[0, i]的和，并保存到一个额外的数组中</strong>，接着将题目转化为：<strong>找到两个前缀和，[0, i)，[0, j)<strong>使得这两个前缀和的差 <strong>&gt;&#x3D;</strong> target，记录此时的子数组长度为：</strong>j-i+1</strong>。后续的操作全都转化为了对<em><strong>前缀和数组</strong></em>的查询操作。</li><li></li></ul></blockquote><h3 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">最大子数组和</a></h3><blockquote><ul><li>这题可以用<strong>动态规划</strong>的方法</li><li>评论区有提到<strong>前缀和数组</strong>的方法：也是提前算出前缀和，<strong>子数组的和可以转化为两个前缀和的差</strong>。对于前缀和数组来说，题目转化为了<strong>股票购买&#x2F;卖出最佳时机（可以多次持有股票，但手上最多只能有一支股票）</strong></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>刷题心得</title>
    <link href="/2024/06/24/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"/>
    <url>/2024/06/24/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="读题关键字"><a href="#读题关键字" class="headerlink" title="读题关键字"></a>读题关键字</h2><ul><li>满足条件的最<em><strong>小</strong></em>整数</li><li>涉及到存储长度类似的：[如果最小的不是32位整数，也返回-1]</li></ul><h2 id="常用数据结构及其方法"><a href="#常用数据结构及其方法" class="headerlink" title="常用数据结构及其方法"></a>常用数据结构及其方法</h2><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><ul><li><string></li><li>substr(start, len) ❗️ 注意这个方法的第二个参数为<u>长度</u></li></ul><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><ul><li><stcak></li><li>push()</li><li>pop() -&gt; 注意返回值为 void，因此取元素只能用top()方法 ⚠️</li><li>top()</li><li>empty()</li><li>begin() ❌ -&gt; 没有这个方法</li><li>size()</li><li>swap() -&gt; <a href="https://cplusplus.com/reference/stack/stack/swap/">交换两个栈的内容</a></li></ul><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><ul><li><queue></li><li>push()</li><li>pop() ⚠️ -&gt; 注意返回值为 void，因此取元素只能用front()方法</li><li>top() ❌ -&gt; 没有这个方法，要使用front()</li><li>front() -&gt; 查看队列头部的元素[先插入的]</li><li>back() -&gt; 查看队列尾部的元素[后插入的]</li><li>empty()</li><li>begin() ❌ -&gt; 没有这个方法</li><li>size()</li><li>swap() -&gt; <a href="https://cplusplus.com/reference/stack/stack/swap/">交换两个栈的内容</a></li></ul><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><ul><li><map></li><li>erase() -&gt; 参数可以为 <strong>iterator</strong>，<strong>key</strong>；也可以为范围参数’[first it, last it)’</li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>单调栈</title>
    <link href="/2024/06/24/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <url>/2024/06/24/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h2 id="优质参考博客"><a href="#优质参考博客" class="headerlink" title="优质参考博客"></a>优质参考博客</h2><ul><li><a href="https://oi-wiki.org/ds/monotonous-stack/">单调栈</a></li></ul><h2 id="重要性质"><a href="#重要性质" class="headerlink" title="重要性质"></a>重要性质</h2><ul><li>弹出时只能从栈顶[st.top()]弹出</li><li>从栈顶到栈底，元素大小呈某种单调趋势</li><li>当欲压入栈的元素不满足这个单调性时，就要把不满足单调性的所有[栈顶]元素弹出 -&gt; 这个性质用到的比较多</li><li>配合数组使用时，栈内可以存储对应元素的下标，而不是元素值</li></ul><h2 id="使用心得"><a href="#使用心得" class="headerlink" title="使用心得"></a>使用心得</h2><ul><li>使用时要注意考虑单调顺序：1️⃣递增，2️⃣递减</li><li>要搞清楚单调栈中记录元素的意义：例如题—[503]，单调栈中记录的是还没有找到下一个更大值的<em><strong>下标</strong></em>, 只要遍历到比栈顶元素值更大的数，就意味着栈顶元素找到了答案，记录答案，然后从栈顶弹出</li><li>一定要注意单调栈里存储的是<em><strong>索引</strong></em>还是<em><strong>元素值</strong></em></li></ul><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><ul><li><a href="https://leetcode.cn/problems/next-greater-element-ii/description/">503.下一个更大元素2</a></li><li><a href="https://leetcode.cn/problems/next-greater-element-iii/description/">556.下一个更大元素3</a>: 变形题，比较有意思！！！</li></ul><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><ul><li>[556] 一定要注意题目的条件 -&gt; <ul><li>满足条件的最小整数</li><li>如果最小的不是32位整数，也返回-1</li></ul></li></ul><h2 id="扩展-循环数组"><a href="#扩展-循环数组" class="headerlink" title="扩展-循环数组"></a>扩展-循环数组</h2><ul><li>处理方式1：将[0:n-1]个个数顺序拷贝到第n个数后面，构成一个普通数组</li><li>处理方式2：遍历[0:2n-1)次，取元素时对下标取模</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>刷题记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2024/06/22/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2024/06/22/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="优质参考博客"><a href="#优质参考博客" class="headerlink" title="优质参考博客"></a>优质参考博客</h2><ul><li><a href="https://oi-wiki.org/ds/dsu/">并查集</a></li><li><a href="https://writings.sh/post/union-find">并查集简记</a></li></ul><h2 id="Leetcode-题目"><a href="#Leetcode-题目" class="headerlink" title="Leetcode 题目"></a>Leetcode 题目</h2><ul><li><a href="https://leetcode.cn/problems/smallest-string-with-swaps/description/">1202.交换字符串中的元素</a></li></ul><h2 id="对应题解"><a href="#对应题解" class="headerlink" title="对应题解"></a>对应题解</h2><ul><li>1202 [from Andy at Leetcode]<blockquote></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> father[<span class="hljs-number">100010</span>];<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><span class="hljs-comment">//并查集find</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> x==father[x]?x:(father[x] = <span class="hljs-built_in">find</span>(father[x]));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span><span class="hljs-comment">//并查集merge</span></span><br><span class="hljs-function">    </span>&#123;<br>        father[<span class="hljs-built_in">find</span>(x)] = <span class="hljs-built_in">find</span>(y);<br>    &#125;<br>    <span class="hljs-function">string <span class="hljs-title">smallestStringWithSwaps</span><span class="hljs-params">(string s, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        string areastr[<span class="hljs-number">100010</span>]; <span class="hljs-comment">//areastr[x]含义为并查集里所有father==x的结点集合</span><br>        <span class="hljs-type">int</span> cnt[<span class="hljs-number">100010</span>] =&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//cnt[x]含义为areastr[x]内的第一个未分配元素</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) father[i] = i;<span class="hljs-comment">//初始化并查集</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i: pairs) <span class="hljs-built_in">merge</span>(i[<span class="hljs-number">1</span>], i[<span class="hljs-number">0</span>]);<span class="hljs-comment">//merge连通结点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>            areastr[<span class="hljs-built_in">find</span>(i)]+=s[i];<span class="hljs-comment">//将s[i]添加到连通结点集合内</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>            <span class="hljs-built_in">sort</span>(areastr[i].<span class="hljs-built_in">begin</span>(),areastr[i].<span class="hljs-built_in">end</span>());<span class="hljs-comment">//对每个连通图内容排序</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>            s[i] = areastr[father[i]][cnt[<span class="hljs-built_in">find</span>(i)]++];<span class="hljs-comment">//根据连通图内排序后结果还原字符串</span><br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>刷题记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDS回环-吞吐量测试记录</title>
    <link href="/2024/06/22/DDS%E5%9B%9E%E7%8E%AF-%E5%90%9E%E5%90%90%E9%87%8F%E6%B5%8B%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/06/22/DDS%E5%9B%9E%E7%8E%AF-%E5%90%9E%E5%90%90%E9%87%8F%E6%B5%8B%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="LW-DDS"><a href="#LW-DDS" class="headerlink" title="LW DDS"></a>LW DDS</h2><ul><li>240607-可以用于毕业小实验数据采集</li><li>240624-用于项目中期考察时的补充实验：回环&#x2F;吞吐量</li></ul><h2 id="Cyclone-DDS"><a href="#Cyclone-DDS" class="headerlink" title="Cyclone DDS"></a>Cyclone DDS</h2><ul><li>240624-用于项目中期考察时的补充实验：回环&#x2F;吞吐量</li></ul><h2 id="RTI-DDS"><a href="#RTI-DDS" class="headerlink" title="RTI DDS"></a>RTI DDS</h2><p>- </p><h2 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h2><ul><li>Cyclone 和 Fast[2.12.0]都定义了0x8007这个PID，但是含义不一样，因此Fast在接收到Cyclone的data(p)报文，进行处理时出错，不会创建参与者代理，因此匹配不了</li><li>FastDDS调试时常用的断点：<ul><li>on_new_cache_change_added() [“Ignore announcement from own RTPSParticipant”] at file: PDPListener.cpp -&gt; 用于处理data(p)报文</li><li>EDPSimplePUBListener::on_new_cache_change_added() at file: EDPSimpleListeners.cpp -&gt; 用于处理data(w)报文</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>日常记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>回文串性质</title>
    <link href="/2024/06/22/%E5%9B%9E%E6%96%87%E4%B8%B2%E6%80%A7%E8%B4%A8/"/>
    <url>/2024/06/22/%E5%9B%9E%E6%96%87%E4%B8%B2%E6%80%A7%E8%B4%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="参考题目"><a href="#参考题目" class="headerlink" title="参考题目"></a>参考题目</h2><ul><li><a href="https://leetcode.cn/problems/lexicographically-smallest-beautiful-string/">2663. 字典序最小的美丽字符串</a></li><li><a href="https://leetcode.cn/problems/find-palindrome-with-fixed-length/description/">2217. 找到指定长度的回文数</a></li></ul><h2 id="重要性质"><a href="#重要性质" class="headerlink" title="重要性质"></a>重要性质</h2><ul><li>aa，aba，很明显，最小模式的回文串只有这两种模式</li><li>对于长度为 m (m &gt; 3) 的回文串，其必包含长度为 m-2 的回文串</li><li>因此，“不包含任何长度为2或更长的回文串” &lt;&#x3D;&#x3D;&gt; “不包含长度为2或3的回文串”</li><li>当用[0-9]的数字来组成回文串，则其长度为n的回文串按大小排序时，有明显的规律</li><li>要注意：回文串是有<em><strong>对称性</strong></em>的，因此长度为n的回文串（由数字组成时），可以由其前(n+1)&#x2F;2个整数部分唯一确定，因为后续的数字与前面的数字成镜像对称</li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li>如果题目中“不包含任何长度为2或更长” 改为-&gt; “不包含任何长度为3&#x2F;4&#x2F;5&#x2F;m或更长”，该怎么做？</li></ul><h2 id="基础：回文串的判别"><a href="#基础：回文串的判别" class="headerlink" title="基础：回文串的判别"></a>基础：回文串的判别</h2><ul><li>可以根据对称性进行回文串的判断<ol><li>区分长度的奇偶性，找到双指针i，j</li><li>i–，j++分别判断s[i] &#x3D;&#x3D; s[j]是否成立</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/06/22/hello-world/"/>
    <url>/2024/06/22/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
