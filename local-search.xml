<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>aarch64-linux-内存管理(一)</title>
    <link href="/2024/06/26/aarch64-linux-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E4%B8%80/"/>
    <url>/2024/06/26/aarch64-linux-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h2 id="优质参考博客"><a href="#优质参考博客" class="headerlink" title="优质参考博客"></a>优质参考博客</h2><ol><li><a href="https://blog.csdn.net/yhb1047818384/category_10345494.html">Linux内存管理-专栏</a></li><li><a href="http://www.wowotech.net/memory_management/memory_model.html">Linux内存模型</a></li><li><a href="https://www.cnblogs.com/liuhailong0112/p/14465697.html">arm64架构linux内核地址转换__pa(x)与__va(x)分析</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg3Mjg2NDQ0NA==&mid=2247485533&idx=1&sn=bf4dc798fc2cbbe0b55dcd0f5360d933&chksm=cee9878ef99e0e98628bd41f0a733f47d955e470d26840d0f07cc5aa7c9f789e746133c39c82&scene=178&cur_album_id=2707075920913924097#rd">底层开发必知的三个内存结构概念</a></li></ol><h2 id="内存硬件结构"><a href="#内存硬件结构" class="headerlink" title="内存硬件结构"></a>内存硬件结构</h2><p>Linux 把物理内存划分为三个层次来管理: 存储节点(Node)、内存管理区(Zone)和页面(Page)</p><ul><li>Node -&gt; struct pglist_data，包含的重要信息有<ul><li>该 Node 包含的Zone数目</li><li>该node中内存的起始页帧号</li><li>该node地址范围内的实际管理的页面数量</li><li>该node地址范围内的所有页面数量，包括空洞的页面</li><li>ZONE_PADDING宏：让前后的成员分布在不同的cache line中, 以空间换取时间</li></ul></li><li>Zone -&gt; struct Zone<ul><li>将node拆分成zone主要还是出于Linux为了兼容各种架构和平台，对不同区域的内存需要采用不同的管理方式和映射方式；32位系统中，内核和用户地址空间按1:3划分，内核地址空间只有1GB，所以不能把1GB以上的内存直接映射到内核地址空间，因此就把不能直接映射的内存划分到了高端内存区</li><li>ZONE_DMA: 只适用于Intel x86架构，ARM架构没有这个区域，用于ISA设备的DMA操作，物理地址范围为0-16MB</li><li>ZONE_DMA32: 在64位的系统上使用32位地址寻址的适合DMA操作的内存区。例如在AMD64系统上，该区域为低4GB的空间。在32位系统上，本区域通常是空的</li><li>ZONE_NORMAL: 指的是<u>可以直接映射到内核空间的内存</u>。也常称为“普通区域”“直接映射区域”“线性映射区域”。所谓线性映射就是物理地址和映射后的虚拟地址存在一种简单的关系，即虚拟地址&#x3D;物理地址+固定偏移。在32位系统上，内核空间和用户空间按1:3划分，那么这个固定偏移就是：<code>0xC0000000</code> - 物理内存起始地址。因此可以看到：在32位系统中，将物理内存地址的低1G[物理内存起始地址(start): start+1G]映射到内核空间[0xc0000000:0xffffffff]</li><li>ZONE_HIGHMEM: 高端内存区，32位时代的产物。在32位系统上，指的是高于<code>896M</code>的物理内存。32位系统中，内核和用户地址空间按1:3划分，内核地址空间只有1GB，所以不能把1GB以上的内存直接映射到内核地址空间，因此就把不能直接映射的内存划分到了高端内存区。要将高于896MB的物理内存映射在内核空间的话，需要通过单独的映射来完成，并且这类映射不能保证物理地址和虚拟地址之间存在固定的对应关系（例如ZONE_NORMAL的固定偏移）<blockquote><p>64位系统中没有这个区域，即没有高端内存。因为64系统的内核虚拟地址空间非常大，不再需要高端内存区域</p></blockquote></li><li>指向所属的Node节点</li><li>空闲内存链表，用于实现伙伴系统</li></ul></li><li>Page -&gt; struct page<ul><li>Linux内核使用page结构体来描述一个物理页面，每一个page frame有一个一一对应的page数据结构，系统中定义了page_to_pfn和pfn_to_page的宏用来在page frame number和page数据结构之间进行转换，具体如何转换是和<a href="http://www.wowotech.net/memory_management/memory_model.html">memory modle</a>相关</li><li>PFN是page frame number的缩写，所谓page frame，就是针对物理内存而言的，把物理内存分成一个个的page size的区域，并且给每一个page 编号，这个号码就是PFN。假设物理内存从0地址开始，那么PFN等于0的那个页帧就是0地址（物理地址）开始的那个page。假设物理内存从x地址开始，那么第一个页帧号码就是（x&gt;&gt;PAGE_SHIFT）</li></ul></li><li>区分系统物理地址空间 VS 内存占据的物理地址空间<ul><li>整个系统的物理地址空间并不是都用于内存，有些也属于I&#x2F;O空间（当然，有些cpu arch有自己独立的io address space）。因此，内存所占据的物理地址空间应该是一个有限的区间，不可能覆盖整个物理地址空间</li></ul></li></ul><ol><li>UMA 与 NUMA<ul><li>UMA: Uniform Memory Access，统一内存访问，每个CPU共享相同的内存地址空间</li><li>NUMA: Non-Uniform Memory Access，非统一内存访问。系统中会有很多的内存节点和多个CPU簇， 所有节点中的CPU可以访问全部的物理内存，但是CPU访问本地的节点速度远快于访问远端的内存节点的速度</li></ul></li></ol><h2 id="启动阶段"><a href="#启动阶段" class="headerlink" title="启动阶段"></a>启动阶段</h2><p>主要问题有：</p><p>1. </p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>动态库vs静态库</title>
    <link href="/2024/06/26/%E5%8A%A8%E6%80%81%E5%BA%93vs%E9%9D%99%E6%80%81%E5%BA%93/"/>
    <url>/2024/06/26/%E5%8A%A8%E6%80%81%E5%BA%93vs%E9%9D%99%E6%80%81%E5%BA%93/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>加减乘除与mod</title>
    <link href="/2024/06/25/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E4%B8%8Emod/"/>
    <url>/2024/06/25/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E4%B8%8Emod/</url>
    
    <content type="html"><![CDATA[<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://leetcode.cn/circle/discuss/mDfnkW/">力扣</a></li></ul><h2 id="记录要点"><a href="#记录要点" class="headerlink" title="记录要点"></a>记录要点</h2><h3 id="两个恒等式"><a href="#两个恒等式" class="headerlink" title="两个恒等式"></a>两个恒等式</h3><ul><li><code>(a + b) mod m = [(a mod m) + (b mod m)] mod m</code></li><li><code>(a b) mod m = [(a mod m) (b mod m)] mod m</code></li></ul><h3 id="幂运算与mod"><a href="#幂运算与mod" class="headerlink" title="幂运算与mod"></a>幂运算与mod</h3><ul><li><font color=DC143C>指数不能随便取余</font>，如果指数在 64 位整数的范围内，可以使用<a href="https://leetcode.cn/problems/powx-n/description/">快速幂</a>计算方法<blockquote><p>注：如果指数超出 64 位整数的范围，需要用「欧拉降幂」处理。</p></blockquote></li></ul><h3 id="负数与mod"><a href="#负数与mod" class="headerlink" title="负数与mod"></a>负数与mod</h3><ul><li>如果<code>x</code>是负数，要采用<code>(x mod m + m) mod m</code>的形式，这样不用判断<code>x</code>是否为负数</li></ul><h3 id="除法与mod"><a href="#除法与mod" class="headerlink" title="除法与mod"></a>除法与mod</h3><ul><li>参考上述链接</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代码实现时，上面的加减乘除通常这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">MOD = <span class="hljs-number">1</span>_000_000_007<br><br><span class="hljs-comment">// 加</span><br>(a + b) % MOD<br><br><span class="hljs-comment">// 减</span><br>(a - b + MOD) % MOD<br><br><span class="hljs-comment">// 取模到 [0,MOD-1] 中，无论正负</span><br>(a % MOD + MOD) % MOD<br><br><span class="hljs-comment">// 乘</span><br>a * b % MOD<br><br><span class="hljs-comment">// 多个数相乘，要步步取模，防止溢出</span><br>a * b % MOD * c % MOD<br><br><span class="hljs-comment">// 除（MOD 是质数且 b 不是 MOD 的倍数）</span><br>a * <span class="hljs-built_in">qpow</span>(b, MOD - <span class="hljs-number">2</span>, MOD) % MOD<br></code></pre></td></tr></table></figure><p>其中 <code>qpow</code> 为快速幂函数。</p>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>子数组相关</title>
    <link href="/2024/06/25/%E5%AD%90%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3/"/>
    <url>/2024/06/25/%E5%AD%90%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><ul><li><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/?envType=study-plan-v2&envId=top-interview-150">209. 长度最小的子数组</a></p></li><li><p><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></p></li></ul><h2 id="对应解答及注意事项"><a href="#对应解答及注意事项" class="headerlink" title="对应解答及注意事项"></a>对应解答及注意事项</h2><h3 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/?envType=study-plan-v2&envId=top-interview-150">长度最小的子数组</a></h3><blockquote><ul><li>这个题是滑动窗口的最佳实践！窗口有左右两个边界索引，有点类似于<em><strong>双指针</strong></em>的方法</li><li>官方题解有一个前缀和的做法：<strong>提前算出[0, i]的和，并保存到一个额外的数组中</strong>，接着将题目转化为：<strong>找到两个前缀和，[0, i)，[0, j)<strong>使得这两个前缀和的差 <strong>&gt;&#x3D;</strong> target，记录此时的子数组长度为：</strong>j-i+1</strong>。后续的操作全都转化为了对<em><strong>前缀和数组</strong></em>的查询操作。</li><li></li></ul></blockquote><h3 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">最大子数组和</a></h3><blockquote><ul><li>这题可以用<strong>动态规划</strong>的方法</li><li>评论区有提到<strong>前缀和数组</strong>的方法：也是提前算出前缀和，<strong>子数组的和可以转化为两个前缀和的差</strong>。对于前缀和数组来说，题目转化为了<strong>股票购买&#x2F;卖出最佳时机（可以多次持有股票，但手上最多只能有一支股票）</strong></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>刷题心得</title>
    <link href="/2024/06/24/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"/>
    <url>/2024/06/24/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="读题关键字"><a href="#读题关键字" class="headerlink" title="读题关键字"></a>读题关键字</h2><ul><li>满足条件的最<em><strong>小</strong></em>整数</li><li>涉及到存储长度类似的：[如果最小的不是32位整数，也返回-1]</li></ul><h3 id="常用编程技巧"><a href="#常用编程技巧" class="headerlink" title="常用编程技巧"></a>常用编程技巧</h3><ul><li>使用程序块为变量赋值，要注意函数块需要使用<font color=#DC143C>()</font>包裹起来：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> sum = (&#123;<br>        <span class="hljs-type">double</span> tmp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; k; j++) tmp += nums[j];<br>        tmp;<br>    &#125;);<br></code></pre></td></tr></table></figure></li></ul><h2 id="常用数据结构及其方法"><a href="#常用数据结构及其方法" class="headerlink" title="常用数据结构及其方法"></a>常用数据结构及其方法</h2><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><ul><li>&lt;string&gt;</li><li>substr(start, len) ❗️ 注意这个方法的第二个参数为<u>长度</u></li></ul><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><ul><li>&lt;stcak&gt;</li><li>push()</li><li>pop() -&gt; 注意返回值为 void，因此取元素只能用top()方法 ❗️</li><li>top()</li><li>empty()</li><li>begin() ❌ -&gt; 没有这个方法</li><li>size()</li><li>swap() -&gt; <a href="https://cplusplus.com/reference/stack/stack/swap/">交换两个栈的内容</a></li></ul><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><ul><li>&lt;queue&gt;</li><li>push()</li><li>pop() ❗️ -&gt; 注意返回值为 void，因此取元素只能用front()方法</li><li>top() ❌ -&gt; 没有这个方法，要使用front()</li><li>front() -&gt; 查看队列头部的元素[先插入的]</li><li>back() -&gt; 查看队列尾部的元素[后插入的]</li><li>empty()</li><li>begin() ❌ -&gt; 没有这个方法</li><li>size()</li><li>swap() -&gt; <a href="https://cplusplus.com/reference/stack/stack/swap/">交换两个栈的内容</a></li></ul><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><ul><li>&lt;mao&gt;</li><li>erase() -&gt; 参数可以为 <strong>iterator</strong>，<strong>key</strong>；也可以为范围参数’[first it, last it)’</li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>单调栈</title>
    <link href="/2024/06/24/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <url>/2024/06/24/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h2 id="优质参考博客"><a href="#优质参考博客" class="headerlink" title="优质参考博客"></a>优质参考博客</h2><ul><li><a href="https://oi-wiki.org/ds/monotonous-stack/">单调栈</a></li></ul><h2 id="重要性质"><a href="#重要性质" class="headerlink" title="重要性质"></a>重要性质</h2><ul><li>弹出时只能从栈顶[st.top()]弹出</li><li>从栈顶到栈底，元素大小呈某种单调趋势</li><li>当欲压入栈的元素不满足这个单调性时，就要把不满足单调性的所有[栈顶]元素弹出 -&gt; 这个性质用到的比较多</li><li>配合数组使用时，栈内可以存储对应元素的下标，而不是元素值</li></ul><h2 id="使用心得"><a href="#使用心得" class="headerlink" title="使用心得"></a>使用心得</h2><ul><li>使用时要注意考虑单调顺序：1️⃣递增，2️⃣递减</li><li>要搞清楚单调栈中记录元素的意义：例如题—[503]，单调栈中记录的是还没有找到下一个更大值的<em><strong>下标</strong></em>, 只要遍历到比栈顶元素值更大的数，就意味着栈顶元素找到了答案，记录答案，然后从栈顶弹出</li><li>一定要注意单调栈里存储的是<em><strong>索引</strong></em>还是<em><strong>元素值</strong></em></li></ul><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><ul><li><a href="https://leetcode.cn/problems/next-greater-element-ii/description/">503.下一个更大元素2</a></li><li><a href="https://leetcode.cn/problems/next-greater-element-iii/description/">556.下一个更大元素3</a>: 变形题，比较有意思！！！</li></ul><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><ul><li>[556] 一定要注意题目的条件 -&gt; <ul><li>满足条件的最小整数</li><li>如果最小的不是32位整数，也返回-1</li></ul></li></ul><h2 id="扩展-循环数组"><a href="#扩展-循环数组" class="headerlink" title="扩展-循环数组"></a>扩展-循环数组</h2><ul><li>处理方式1：将[0:n-1]个个数顺序拷贝到第n个数后面，构成一个普通数组</li><li>处理方式2：遍历[0:2n-1)次，取元素时对下标取模</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>刷题记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2024/06/22/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2024/06/22/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="优质参考博客"><a href="#优质参考博客" class="headerlink" title="优质参考博客"></a>优质参考博客</h2><ul><li><a href="https://oi-wiki.org/ds/dsu/">并查集</a></li><li><a href="https://writings.sh/post/union-find">并查集简记</a></li></ul><h2 id="Leetcode-题目"><a href="#Leetcode-题目" class="headerlink" title="Leetcode 题目"></a>Leetcode 题目</h2><ul><li><a href="https://leetcode.cn/problems/smallest-string-with-swaps/description/">1202.交换字符串中的元素</a></li></ul><h2 id="对应题解"><a href="#对应题解" class="headerlink" title="对应题解"></a>对应题解</h2><ul><li>1202 [from Andy at Leetcode]<blockquote></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> father[<span class="hljs-number">100010</span>];<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><span class="hljs-comment">//并查集find</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> x==father[x]?x:(father[x] = <span class="hljs-built_in">find</span>(father[x]));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span><span class="hljs-comment">//并查集merge</span></span><br><span class="hljs-function">    </span>&#123;<br>        father[<span class="hljs-built_in">find</span>(x)] = <span class="hljs-built_in">find</span>(y);<br>    &#125;<br>    <span class="hljs-function">string <span class="hljs-title">smallestStringWithSwaps</span><span class="hljs-params">(string s, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        string areastr[<span class="hljs-number">100010</span>]; <span class="hljs-comment">//areastr[x]含义为并查集里所有father==x的结点集合</span><br>        <span class="hljs-type">int</span> cnt[<span class="hljs-number">100010</span>] =&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//cnt[x]含义为areastr[x]内的第一个未分配元素</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) father[i] = i;<span class="hljs-comment">//初始化并查集</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i: pairs) <span class="hljs-built_in">merge</span>(i[<span class="hljs-number">1</span>], i[<span class="hljs-number">0</span>]);<span class="hljs-comment">//merge连通结点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>            areastr[<span class="hljs-built_in">find</span>(i)]+=s[i];<span class="hljs-comment">//将s[i]添加到连通结点集合内</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>            <span class="hljs-built_in">sort</span>(areastr[i].<span class="hljs-built_in">begin</span>(),areastr[i].<span class="hljs-built_in">end</span>());<span class="hljs-comment">//对每个连通图内容排序</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>            s[i] = areastr[father[i]][cnt[<span class="hljs-built_in">find</span>(i)]++];<span class="hljs-comment">//根据连通图内排序后结果还原字符串</span><br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>刷题记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDS回环-吞吐量测试记录</title>
    <link href="/2024/06/22/DDS%E5%9B%9E%E7%8E%AF-%E5%90%9E%E5%90%90%E9%87%8F%E6%B5%8B%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/06/22/DDS%E5%9B%9E%E7%8E%AF-%E5%90%9E%E5%90%90%E9%87%8F%E6%B5%8B%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="LW-DDS"><a href="#LW-DDS" class="headerlink" title="LW DDS"></a>LW DDS</h2><ul><li>240607-可以用于毕业小实验数据采集</li><li>240624-用于项目中期考察时的补充实验：回环&#x2F;吞吐量</li></ul><h2 id="Cyclone-DDS"><a href="#Cyclone-DDS" class="headerlink" title="Cyclone DDS"></a>Cyclone DDS</h2><ul><li>240624-用于项目中期考察时的补充实验：回环&#x2F;吞吐量</li></ul><h2 id="RTI-DDS"><a href="#RTI-DDS" class="headerlink" title="RTI DDS"></a>RTI DDS</h2><p>- </p><h2 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h2><ul><li>Cyclone 和 Fast[2.12.0]都定义了0x8007这个PID，但是含义不一样，因此Fast在接收到Cyclone的data(p)报文，进行处理时出错，不会创建参与者代理，因此匹配不了</li><li>FastDDS调试时常用的断点：<ul><li>on_new_cache_change_added() [“Ignore announcement from own RTPSParticipant”] at file: PDPListener.cpp -&gt; 用于处理data(p)报文</li><li>EDPSimplePUBListener::on_new_cache_change_added() at file: EDPSimpleListeners.cpp -&gt; 用于处理data(w)报文</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>日常记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>回文串性质</title>
    <link href="/2024/06/22/%E5%9B%9E%E6%96%87%E4%B8%B2%E6%80%A7%E8%B4%A8/"/>
    <url>/2024/06/22/%E5%9B%9E%E6%96%87%E4%B8%B2%E6%80%A7%E8%B4%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="参考题目"><a href="#参考题目" class="headerlink" title="参考题目"></a>参考题目</h2><ul><li><a href="https://leetcode.cn/problems/lexicographically-smallest-beautiful-string/">2663. 字典序最小的美丽字符串</a></li><li><a href="https://leetcode.cn/problems/find-palindrome-with-fixed-length/description/">2217. 找到指定长度的回文数</a></li></ul><h2 id="重要性质"><a href="#重要性质" class="headerlink" title="重要性质"></a>重要性质</h2><ul><li>aa，aba，很明显，最小模式的回文串只有这两种模式</li><li>对于长度为 m (m &gt; 3) 的回文串，其必包含长度为 m-2 的回文串</li><li>因此，“不包含任何长度为2或更长的回文串” &lt;&#x3D;&#x3D;&gt; “不包含长度为2或3的回文串”</li><li>当用[0-9]的数字来组成回文串，则其长度为n的回文串按大小排序时，有明显的规律</li><li>要注意：回文串是有<em><strong>对称性</strong></em>的，因此长度为n的回文串（由数字组成时），可以由其前(n+1)&#x2F;2个整数部分唯一确定，因为后续的数字与前面的数字成镜像对称</li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li>如果题目中“不包含任何长度为2或更长” 改为-&gt; “不包含任何长度为3&#x2F;4&#x2F;5&#x2F;m或更长”，该怎么做？</li></ul><h2 id="基础：回文串的判别"><a href="#基础：回文串的判别" class="headerlink" title="基础：回文串的判别"></a>基础：回文串的判别</h2><ul><li>可以根据对称性进行回文串的判断<ol><li>区分长度的奇偶性，找到双指针i，j</li><li>i–，j++分别判断s[i] &#x3D;&#x3D; s[j]是否成立</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/06/22/hello-world/"/>
    <url>/2024/06/22/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
